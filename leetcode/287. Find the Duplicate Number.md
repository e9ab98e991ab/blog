# 287. Find the Duplicate Number

Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

Note:

1. You must not modify the array (assume the array is read only).
2. You must use only constant, O(1) extra space.
3. Your runtime complexity should be less than O(n2).
4. There is only one duplicate number in the array, but it could be repeated more than once.

# 思路

核心思想：二分查找法(更广义的二分查找)，重要的是确定被比较的值

确定被比较的值：

 1. 依题意，n+1个数，元素范围[1,n]，那么被比较的元素的范围为[1,n]
 2. 确定被比较的值mid为当前范围的中间值，mid与数组每个元素比较，记录小于等于mid的元素个数count
 3. count小于等于mid，那么表示重复元素值要大于mid，此时mid的范围缩小到[mid+1,n]，反之为[1,mid]
 4. 重复步骤二，知道范围缩小到一个元素

示例：

```
low mid         high
|   |           |
1   2   3   1   4
--------------------->count=3

mid
low high           
|   |           
1   2   3   1   4
--------------------->count=2

high
low 
|              
1   2   3   1   4
--------------------->return 1
```

# 代码实现

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int low,mid,high,count;
        low=1;
        high=nums.length-1;
        while (low<high){
            count=0;
            mid=(low+high)/2;
            for(int i : nums){
                if(i<=mid){
                    count++;
                }
            }
            if(count<=mid){
                low=mid+1;
            }else{
                high=mid;
            }
        }
        return low;
    }
}
```

# 另一种天才的解法

算法：

suppose the array is

index: 0 1 2 3 4 5

value: 2 5 1 1 4 3
first subtract 1 from each element in the array, so it is much easy to understand.
use the value as pointer. the array becomes:

index: 0 1 2 3 4 5

value: 1 4 0 0 3 2

![](https://www.github.com/wslaimin/blog/raw/master/pics/287_find_the_Duplicate_Number.png)

Second if the array is

index: 0 1 2 3 4 5

value: 0 1 2 4 2 3
we must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.

代码实现：

```java
public int findDuplicate(int[] nums) {
    int n = nums.length;
    int slow = n;
    int fast = n;
    do{
        slow = nums[slow-1];
        fast = nums[nums[fast-1]-1];
    }while(slow != fast);
    slow = n;
    while(slow != fast){
        slow = nums[slow-1];
        fast = nums[fast-1];
    }
    return slow;
}
```