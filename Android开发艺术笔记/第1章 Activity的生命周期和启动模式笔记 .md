#Activiyt的生命周期
##Activity生命周期方法
onRestart:当当前Activity从不可见重新变为可见状态时，onRestart就会被调用。
onStart:Activity已经可见了，但是还没有出现在前台，还无法和用户交互。
onResume:出现在前台并开始活动。
onPause:正常情况下，紧接着onStop就会被调用。在特殊情况下，如果这个时候快速地再回到当前Activity，那么onResume会被调用。onPause必须执行完，新Activity的onResume才会执行。当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause->onStop。有一种特殊情况，如果新Activity采用了透明主题，那么当前Activity不会回调onStop。

onStart和onResume，onPause和onStop的区别：onStart和onStop是从Activity是否可见这个角度来回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的。

我们知道onPause和onStop都不能执行耗时的操作，尤其是onPause，这也意味着，我们应当尽量在onStop中做操作，从而使得新Activity尽快显示出来并切换到前台。
##Activity状态保存
当系统配置发生改变后，Activity会被销毁，其onPause、onStop、onDestroy均会被调用，并在onStop之前调用onSaveInstanceState来保存当前Activity的状态，它既可能在onPause之前调用，也可能在onPause之后调用。onReStoreInstanceState在onStart之后调用。

当Activity在异常情况下需要重新创建时，系统默认为我们保存当前Activity的视图结构，并且在Activity重启后为我们恢复这些数据，比如文本框中用户输入的数据、ListView滚动的位置等，前提是View有指定id，没有指定id，系统不会做保存。

关于保存和恢复View层次结构，系统的工作流程是这样的：首先Activity被意外终止时，Activity会调用onSaveInstanceState去保存数据，然后Activity会委托Window去保存数据，接着Window再委托它上面的顶级容器去保存数据，顶层容器是一个ViewGroup，一般来说它很可能是DecorView。最后顶层容器再去一一通知它的子元素来保存数据。
由此，可以得出Activity的层级关系：
